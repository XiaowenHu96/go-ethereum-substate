package vm
import (
	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/math"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/holiman/uint256"
)

// This file is generated by the meta-compiler

const SIVM_NOP = 256;
const SIVM_START = 257;
func opNop(pc *uint64, in *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
	panic("This should never be called")
}
func opInvalid(pc *uint64, in *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
	op := scope.Contract.GetOp(*pc)
    return nil, &ErrInvalidOpCode{opcode: op};
}
func gas_check(op OpCode, in *GethEVMInterpreter, scope *ScopeContext)  error {
// if in.cfg.Debug {
// 	logged, pcCopy, gasCopy = false, pc, contract.Gas
// }
operation := in.cfg.JumpTable[op]
if operation == nil {
	return &ErrInvalidOpCode{opcode: op}
}
if sLen := scope.Stack.len(); sLen < operation.minStack {
	return &ErrStackUnderflow{stackLen: sLen, required: operation.minStack}
} else if sLen > operation.maxStack {
	return &ErrStackOverflow{stackLen: sLen, limit: operation.maxStack}
}
// if in.readOnly && in.evm.chainRules.IsByzantium {
// 	if operation.writes || (op == CALL && scope.Stack.Back(2).Sign() != 0) {
// 		return ErrWriteProtection
// 	}
// }
cost := operation.constantGas // For tracing
if !scope.Contract.UseGas(operation.constantGas) {
	return ErrOutOfGas
}
var memorySize uint64
if operation.memorySize != nil {
	memSize, overflow := operation.memorySize(scope.Stack)
	if overflow {
		return ErrGasUintOverflow
	}
	if memorySize, overflow = math.SafeMul(toWordSize(memSize), 32); overflow {
		return ErrGasUintOverflow
	}
}
if operation.dynamicGas != nil {
	var dynamicCost uint64
	dynamicCost, err := operation.dynamicGas(in.evm, scope.Contract, scope.Stack, scope.Memory, memorySize)
	cost += dynamicCost // total cost, for debug tracing
	if err != nil || !scope.Contract.UseGas(dynamicCost) {
		return ErrOutOfGas
	}
}
if memorySize > 0 {
	scope.Memory.Resize(memorySize)
}
// if in.cfg.Debug {
// 	in.cfg.Tracer.CaptureState(in.evm, pc, op, gasCopy, cost, callContext, // in.returnData, in.evm.Depth, err)
// 	logged = true
//}
return nil}
func aggregate_const_gas_check(ops []OpCode, interpreter *GethEVMInterpreter, scope *ScopeContext) error {
	var total_cost uint64 = 0
	for _, op := range ops {
		operation := interpreter.cfg.JumpTable[op]
		total_cost += operation.constantGas
	}
	if !scope.Contract.UseGas(total_cost) {
		return ErrOutOfGas
	}
	return nil
}
func dynamic_gas_check(op OpCode, in *GethEVMInterpreter, scope *ScopeContext) error {
	operation := in.cfg.JumpTable[op]
	var memorySize uint64
	if operation.memorySize != nil {
		memSize, overflow := operation.memorySize(scope.Stack)
		if overflow {
			return ErrGasUintOverflow
		}
		if memorySize, overflow = math.SafeMul(toWordSize(memSize), 32); overflow {
			return ErrGasUintOverflow
		}
	}
if operation.dynamicGas != nil {
    var dynamicCost uint64
    dynamicCost, err := operation.dynamicGas(in.evm, scope.Contract, scope.Stack, scope.Memory, memorySize)
    if err != nil || !scope.Contract.UseGas(dynamicCost) {
        return ErrOutOfGas
    }
}
	if memorySize > 0 {
		scope.Memory.Resize(memorySize)
	}
    return nil
}
func opPush2(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+2 < endMin {
       endMin = startMin + 2
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 2)))
   *pc += 2
   return nil, nil
}

func opPush3(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+3 < endMin {
       endMin = startMin + 3
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 3)))
   *pc += 3
   return nil, nil
}

func opPush4(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+4 < endMin {
       endMin = startMin + 4
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 4)))
   *pc += 4
   return nil, nil
}

func opPush5(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+5 < endMin {
       endMin = startMin + 5
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 5)))
   *pc += 5
   return nil, nil
}

func opPush6(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+6 < endMin {
       endMin = startMin + 6
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 6)))
   *pc += 6
   return nil, nil
}

func opPush7(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+7 < endMin {
       endMin = startMin + 7
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 7)))
   *pc += 7
   return nil, nil
}

func opPush8(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+8 < endMin {
       endMin = startMin + 8
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 8)))
   *pc += 8
   return nil, nil
}

func opPush9(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+9 < endMin {
       endMin = startMin + 9
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 9)))
   *pc += 9
   return nil, nil
}

func opPush10(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+10 < endMin {
       endMin = startMin + 10
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 10)))
   *pc += 10
   return nil, nil
}

func opPush11(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+11 < endMin {
       endMin = startMin + 11
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 11)))
   *pc += 11
   return nil, nil
}

func opPush12(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+12 < endMin {
       endMin = startMin + 12
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 12)))
   *pc += 12
   return nil, nil
}

func opPush13(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+13 < endMin {
       endMin = startMin + 13
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 13)))
   *pc += 13
   return nil, nil
}

func opPush14(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+14 < endMin {
       endMin = startMin + 14
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 14)))
   *pc += 14
   return nil, nil
}

func opPush15(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+15 < endMin {
       endMin = startMin + 15
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 15)))
   *pc += 15
   return nil, nil
}

func opPush16(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+16 < endMin {
       endMin = startMin + 16
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 16)))
   *pc += 16
   return nil, nil
}

func opPush17(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+17 < endMin {
       endMin = startMin + 17
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 17)))
   *pc += 17
   return nil, nil
}

func opPush18(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+18 < endMin {
       endMin = startMin + 18
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 18)))
   *pc += 18
   return nil, nil
}

func opPush19(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+19 < endMin {
       endMin = startMin + 19
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 19)))
   *pc += 19
   return nil, nil
}

func opPush20(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+20 < endMin {
       endMin = startMin + 20
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 20)))
   *pc += 20
   return nil, nil
}

func opPush21(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+21 < endMin {
       endMin = startMin + 21
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 21)))
   *pc += 21
   return nil, nil
}

func opPush22(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+22 < endMin {
       endMin = startMin + 22
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 22)))
   *pc += 22
   return nil, nil
}

func opPush23(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+23 < endMin {
       endMin = startMin + 23
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 23)))
   *pc += 23
   return nil, nil
}

func opPush24(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+24 < endMin {
       endMin = startMin + 24
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 24)))
   *pc += 24
   return nil, nil
}

func opPush25(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+25 < endMin {
       endMin = startMin + 25
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 25)))
   *pc += 25
   return nil, nil
}

func opPush26(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+26 < endMin {
       endMin = startMin + 26
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 26)))
   *pc += 26
   return nil, nil
}

func opPush27(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+27 < endMin {
       endMin = startMin + 27
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 27)))
   *pc += 27
   return nil, nil
}

func opPush28(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+28 < endMin {
       endMin = startMin + 28
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 28)))
   *pc += 28
   return nil, nil
}

func opPush29(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+29 < endMin {
       endMin = startMin + 29
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 29)))
   *pc += 29
   return nil, nil
}

func opPush30(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+30 < endMin {
       endMin = startMin + 30
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 30)))
   *pc += 30
   return nil, nil
}

func opPush31(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+31 < endMin {
       endMin = startMin + 31
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 31)))
   *pc += 31
   return nil, nil
}

func opPush32(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
   codeLen := len(scope.Contract.Code)
   startMin := codeLen
   if int(*pc+1) < startMin {
   	startMin = int(*pc + 1)
   }
   endMin := codeLen
   if startMin+32 < endMin {
       endMin = startMin + 32
   }
   integer := new(uint256.Int)
   scope.Stack.push(integer.SetBytes(common.RightPadBytes(
   	scope.Contract.Code[startMin:endMin], 32)))
   *pc += 32
   return nil, nil
}

func opLog0(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
    if interpreter.readOnly {
    	return nil, ErrWriteProtection
    }
    topics := make([]common.Hash, 0)
    stack := scope.Stack
    mStart, mSize := stack.pop(), stack.pop()
    for i := 0; i < 0; i++ {
    	addr := stack.pop()
    	topics[i] = addr.Bytes32()
    }
    d := scope.Memory.GetCopy(int64(mStart.Uint64()), int64(mSize.Uint64()))
    interpreter.evm.StateDB.AddLog(&types.Log{
    	Address: scope.Contract.Address(),
    	Topics:  topics,
    	Data:    d,
    	BlockNumber: interpreter.evm.Context.BlockNumber.Uint64(),
    })
   return nil, nil
}

func opLog1(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
    if interpreter.readOnly {
    	return nil, ErrWriteProtection
    }
    topics := make([]common.Hash, 1)
    stack := scope.Stack
    mStart, mSize := stack.pop(), stack.pop()
    for i := 0; i < 1; i++ {
    	addr := stack.pop()
    	topics[i] = addr.Bytes32()
    }
    d := scope.Memory.GetCopy(int64(mStart.Uint64()), int64(mSize.Uint64()))
    interpreter.evm.StateDB.AddLog(&types.Log{
    	Address: scope.Contract.Address(),
    	Topics:  topics,
    	Data:    d,
    	BlockNumber: interpreter.evm.Context.BlockNumber.Uint64(),
    })
   return nil, nil
}

func opLog2(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
    if interpreter.readOnly {
    	return nil, ErrWriteProtection
    }
    topics := make([]common.Hash, 2)
    stack := scope.Stack
    mStart, mSize := stack.pop(), stack.pop()
    for i := 0; i < 2; i++ {
    	addr := stack.pop()
    	topics[i] = addr.Bytes32()
    }
    d := scope.Memory.GetCopy(int64(mStart.Uint64()), int64(mSize.Uint64()))
    interpreter.evm.StateDB.AddLog(&types.Log{
    	Address: scope.Contract.Address(),
    	Topics:  topics,
    	Data:    d,
    	BlockNumber: interpreter.evm.Context.BlockNumber.Uint64(),
    })
   return nil, nil
}

func opLog3(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
    if interpreter.readOnly {
    	return nil, ErrWriteProtection
    }
    topics := make([]common.Hash, 3)
    stack := scope.Stack
    mStart, mSize := stack.pop(), stack.pop()
    for i := 0; i < 3; i++ {
    	addr := stack.pop()
    	topics[i] = addr.Bytes32()
    }
    d := scope.Memory.GetCopy(int64(mStart.Uint64()), int64(mSize.Uint64()))
    interpreter.evm.StateDB.AddLog(&types.Log{
    	Address: scope.Contract.Address(),
    	Topics:  topics,
    	Data:    d,
    	BlockNumber: interpreter.evm.Context.BlockNumber.Uint64(),
    })
   return nil, nil
}

func opLog4(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
    if interpreter.readOnly {
    	return nil, ErrWriteProtection
    }
    topics := make([]common.Hash, 4)
    stack := scope.Stack
    mStart, mSize := stack.pop(), stack.pop()
    for i := 0; i < 4; i++ {
    	addr := stack.pop()
    	topics[i] = addr.Bytes32()
    }
    d := scope.Memory.GetCopy(int64(mStart.Uint64()), int64(mSize.Uint64()))
    interpreter.evm.StateDB.AddLog(&types.Log{
    	Address: scope.Contract.Address(),
    	Topics:  topics,
    	Data:    d,
    	BlockNumber: interpreter.evm.Context.BlockNumber.Uint64(),
    })
   return nil, nil
}

func SI_SELFDESTRUCT(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(255, interpreter, scope);
if err != nil {
return nil, err }
if interpreter.readOnly && interpreter.evm.chainRules.IsByzantium {
    return nil, ErrWriteProtection
}
res, err = opSuicide(pc, interpreter, scope);
return res, ErrSIVMHalts
return res, err }
func SI_REVERT(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(253, interpreter, scope);
if err != nil {
return nil, err }
res, err = opRevert(pc, interpreter, scope);
interpreter.returnData = res 
return res, ErrExecutionReverted
return res, err }
func SI_STATICCALL(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(250, interpreter, scope);
if err != nil {
return nil, err }
res, err = opStaticCall(pc, interpreter, scope);
interpreter.returnData = res 
*pc ++
return res, err }
func SI_CREATE2(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(245, interpreter, scope);
if err != nil {
return nil, err }
if interpreter.readOnly && interpreter.evm.chainRules.IsByzantium {
    return nil, ErrWriteProtection
}
res, err = opCreate2(pc, interpreter, scope);
interpreter.returnData = res 
*pc ++
return res, err }
func SI_DELEGATECALL(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(244, interpreter, scope);
if err != nil {
return nil, err }
res, err = opDelegateCall(pc, interpreter, scope);
interpreter.returnData = res 
*pc ++
return res, err }
func SI_RETURN(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(243, interpreter, scope);
if err != nil {
return nil, err }
res, err = opReturn(pc, interpreter, scope);
return res, ErrSIVMHalts
return res, err }
func SI_CALLCODE(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(242, interpreter, scope);
if err != nil {
return nil, err }
res, err = opCallCode(pc, interpreter, scope);
interpreter.returnData = res 
*pc ++
return res, err }
func SI_CALL(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(241, interpreter, scope);
if err != nil {
return nil, err }
if interpreter.readOnly && interpreter.evm.chainRules.IsByzantium && scope.Stack.Back(2).Sign() != 0 {
    return nil, ErrWriteProtection
}
res, err = opCall(pc, interpreter, scope);
interpreter.returnData = res 
*pc ++
return res, err }
func SI_CREATE(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(240, interpreter, scope);
if err != nil {
return nil, err }
if interpreter.readOnly && interpreter.evm.chainRules.IsByzantium {
    return nil, ErrWriteProtection
}
res, err = opCreate(pc, interpreter, scope);
interpreter.returnData = res 
*pc ++
return res, err }
func SI_LOG4(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(164, interpreter, scope);
if err != nil {
return nil, err }
if interpreter.readOnly && interpreter.evm.chainRules.IsByzantium {
    return nil, ErrWriteProtection
}
res, err = opLog4(pc, interpreter, scope);
*pc ++
return res, err }
func SI_LOG3(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(163, interpreter, scope);
if err != nil {
return nil, err }
if interpreter.readOnly && interpreter.evm.chainRules.IsByzantium {
    return nil, ErrWriteProtection
}
res, err = opLog3(pc, interpreter, scope);
*pc ++
return res, err }
func SI_LOG2(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(162, interpreter, scope);
if err != nil {
return nil, err }
if interpreter.readOnly && interpreter.evm.chainRules.IsByzantium {
    return nil, ErrWriteProtection
}
res, err = opLog2(pc, interpreter, scope);
*pc ++
return res, err }
func SI_LOG1(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(161, interpreter, scope);
if err != nil {
return nil, err }
if interpreter.readOnly && interpreter.evm.chainRules.IsByzantium {
    return nil, ErrWriteProtection
}
res, err = opLog1(pc, interpreter, scope);
*pc ++
return res, err }
func SI_LOG0(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(160, interpreter, scope);
if err != nil {
return nil, err }
if interpreter.readOnly && interpreter.evm.chainRules.IsByzantium {
    return nil, ErrWriteProtection
}
res, err = opLog0(pc, interpreter, scope);
*pc ++
return res, err }
func SI_SWAP16(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(159, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(17)
*pc ++
return res, err }
func SI_BASEFEE(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(72, interpreter, scope);
if err != nil {
return nil, err }
res, err = opBaseFee(pc, interpreter, scope);
*pc ++
return res, err }
func SI_SELFBALANCE(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(71, interpreter, scope);
if err != nil {
return nil, err }
res, err = opSelfBalance(pc, interpreter, scope);
*pc ++
return res, err }
func SI_GASPRICE(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(58, interpreter, scope);
if err != nil {
return nil, err }
res, err = opGasprice(pc, interpreter, scope);
*pc ++
return res, err }
func SI_CODECOPY(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(57, interpreter, scope);
if err != nil {
return nil, err }
res, err = opCodeCopy(pc, interpreter, scope);
*pc ++
return res, err }
func SI_CODESIZE(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(56, interpreter, scope);
if err != nil {
return nil, err }
res, err = opCodeSize(pc, interpreter, scope);
*pc ++
return res, err }
func SI_CALLDATACOPY(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(55, interpreter, scope);
if err != nil {
return nil, err }
res, err = opCallDataCopy(pc, interpreter, scope);
*pc ++
return res, err }
func SI_CALLDATASIZE(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(54, interpreter, scope);
if err != nil {
return nil, err }
res, err = opCallDataSize(pc, interpreter, scope);
*pc ++
return res, err }
func SI_CALLDATALOAD(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(53, interpreter, scope);
if err != nil {
return nil, err }
res, err = opCallDataLoad(pc, interpreter, scope);
*pc ++
return res, err }
func SI_CALLVALUE(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(52, interpreter, scope);
if err != nil {
return nil, err }
res, err = opCallValue(pc, interpreter, scope);
*pc ++
return res, err }
func SI_CALLER(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(51, interpreter, scope);
if err != nil {
return nil, err }
res, err = opCaller(pc, interpreter, scope);
*pc ++
return res, err }
func SI_ORIGIN(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(50, interpreter, scope);
if err != nil {
return nil, err }
res, err = opOrigin(pc, interpreter, scope);
*pc ++
return res, err }
func SI_CHAINID(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(70, interpreter, scope);
if err != nil {
return nil, err }
res, err = opChainID(pc, interpreter, scope);
*pc ++
return res, err }
func SI_SIGNEXTEND(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(11, interpreter, scope);
if err != nil {
return nil, err }
res, err = opSignExtend(pc, interpreter, scope);
*pc ++
return res, err }
func SI_DUP11(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(138, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(11)
*pc ++
return res, err }
func SI_GASLIMIT(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(69, interpreter, scope);
if err != nil {
return nil, err }
res, err = opGasLimit(pc, interpreter, scope);
*pc ++
return res, err }
func SI_EXP(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(10, interpreter, scope);
if err != nil {
return nil, err }
res, err = opExp(pc, interpreter, scope);
*pc ++
return res, err }
func SI_DUP10(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(137, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(10)
*pc ++
return res, err }
func SI_DIFFICULTY(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(68, interpreter, scope);
if err != nil {
return nil, err }
res, err = opDifficulty(pc, interpreter, scope);
*pc ++
return res, err }
func SI_MULMOD(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(9, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMulmod(pc, interpreter, scope);
*pc ++
return res, err }
func SI_DUP9(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(136, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(9)
*pc ++
return res, err }
func SI_NUMBER(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(67, interpreter, scope);
if err != nil {
return nil, err }
res, err = opNumber(pc, interpreter, scope);
*pc ++
return res, err }
func SI_ADDMOD(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(8, interpreter, scope);
if err != nil {
return nil, err }
res, err = opAddmod(pc, interpreter, scope);
*pc ++
return res, err }
func SI_DUP8(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(135, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(8)
*pc ++
return res, err }
func SI_TIMESTAMP(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(66, interpreter, scope);
if err != nil {
return nil, err }
res, err = opTimestamp(pc, interpreter, scope);
*pc ++
return res, err }
func SI_SMOD(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(7, interpreter, scope);
if err != nil {
return nil, err }
res, err = opSmod(pc, interpreter, scope);
*pc ++
return res, err }
func SI_DUP7(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(134, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(7)
*pc ++
return res, err }
func SI_COINBASE(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(65, interpreter, scope);
if err != nil {
return nil, err }
res, err = opCoinbase(pc, interpreter, scope);
*pc ++
return res, err }
func SI_MOD(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(6, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMod(pc, interpreter, scope);
*pc ++
return res, err }
func SI_DUP6(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(133, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(6)
*pc ++
return res, err }
func SI_BLOCKHASH(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(64, interpreter, scope);
if err != nil {
return nil, err }
res, err = opBlockhash(pc, interpreter, scope);
*pc ++
return res, err }
func SI_SDIV(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(5, interpreter, scope);
if err != nil {
return nil, err }
res, err = opSdiv(pc, interpreter, scope);
*pc ++
return res, err }
func SI_DUP5(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(132, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(5)
*pc ++
return res, err }
func SI_EXTCODEHASH(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(63, interpreter, scope);
if err != nil {
return nil, err }
res, err = opExtCodeHash(pc, interpreter, scope);
*pc ++
return res, err }
func SI_DIV(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(4, interpreter, scope);
if err != nil {
return nil, err }
res, err = opDiv(pc, interpreter, scope);
*pc ++
return res, err }
func SI_DUP4(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(131, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(4)
*pc ++
return res, err }
func SI_LT(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(16, interpreter, scope);
if err != nil {
return nil, err }
res, err = opLt(pc, interpreter, scope);
*pc ++
return res, err }
func SI_DUP16(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(143, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(16)
*pc ++
return res, err }
func SI_RETURNDATACOPY(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(62, interpreter, scope);
if err != nil {
return nil, err }
res, err = opReturnDataCopy(pc, interpreter, scope);
if err != nil {
return nil, err }
*pc ++
return res, err }
func SI_SUB(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(3, interpreter, scope);
if err != nil {
return nil, err }
res, err = opSub(pc, interpreter, scope);
*pc ++
return res, err }
func SI_DUP3(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(130, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(3)
*pc ++
return res, err }
func SI_SHA3(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(32, interpreter, scope);
if err != nil {
return nil, err }
res, err = opSha3(pc, interpreter, scope);
*pc ++
return res, err }
func SI_RETURNDATASIZE(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(61, interpreter, scope);
if err != nil {
return nil, err }
res, err = opReturnDataSize(pc, interpreter, scope);
*pc ++
return res, err }
func SI_MUL(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(2, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMul(pc, interpreter, scope);
*pc ++
return res, err }
func SI_DUP2(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(129, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(2)
*pc ++
return res, err }
func SI_EXTCODECOPY(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(60, interpreter, scope);
if err != nil {
return nil, err }
res, err = opExtCodeCopy(pc, interpreter, scope);
*pc ++
return res, err }
func SI_ADD(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(1, interpreter, scope);
if err != nil {
return nil, err }
res, err = opAdd(pc, interpreter, scope);
*pc ++
return res, err }
func SI_DUP1(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(128, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(1)
*pc ++
return res, err }
func SI_EXTCODESIZE(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(59, interpreter, scope);
if err != nil {
return nil, err }
res, err = opExtCodeSize(pc, interpreter, scope);
*pc ++
return res, err }
func SI_STOP(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(0, interpreter, scope);
if err != nil {
return nil, err }
res, err = opStop(pc, interpreter, scope);
return res, ErrSIVMHalts
return res, err }
func SI_PUSH32(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(127, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush32(pc, interpreter, scope);
*pc ++
return res, err }
func SI_SAR(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(29, interpreter, scope);
if err != nil {
return nil, err }
res, err = opSAR(pc, interpreter, scope);
*pc ++
return res, err }
func SI_SWAP13(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(156, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(14)
*pc ++
return res, err }
func SI_GT(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(17, interpreter, scope);
if err != nil {
return nil, err }
res, err = opGt(pc, interpreter, scope);
*pc ++
return res, err }
func SI_SWAP1(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(144, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(2)
*pc ++
return res, err }
func SI_SLT(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(18, interpreter, scope);
if err != nil {
return nil, err }
res, err = opSlt(pc, interpreter, scope);
*pc ++
return res, err }
func SI_SWAP2(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(145, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(3)
*pc ++
return res, err }
func SI_SGT(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(19, interpreter, scope);
if err != nil {
return nil, err }
res, err = opSgt(pc, interpreter, scope);
*pc ++
return res, err }
func SI_SWAP3(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(146, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(4)
*pc ++
return res, err }
func SI_ADDRESS(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(48, interpreter, scope);
if err != nil {
return nil, err }
res, err = opAddress(pc, interpreter, scope);
*pc ++
return res, err }
func SI_EQ(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(20, interpreter, scope);
if err != nil {
return nil, err }
res, err = opEq(pc, interpreter, scope);
*pc ++
return res, err }
func SI_SWAP4(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(147, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(5)
*pc ++
return res, err }
func SI_BALANCE(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(49, interpreter, scope);
if err != nil {
return nil, err }
res, err = opBalance(pc, interpreter, scope);
*pc ++
return res, err }
func SI_POP(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(80, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.pop()
*pc ++
return res, err }
func SI_ISZERO(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(21, interpreter, scope);
if err != nil {
return nil, err }
res, err = opIszero(pc, interpreter, scope);
*pc ++
return res, err }
func SI_SWAP5(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(148, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(6)
*pc ++
return res, err }
func SI_MLOAD(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
return res, err }
func SI_AND(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(22, interpreter, scope);
if err != nil {
return nil, err }
res, err = opAnd(pc, interpreter, scope);
*pc ++
return res, err }
func SI_SWAP6(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(149, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(7)
*pc ++
return res, err }
func SI_MSTORE(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
return res, err }
func SI_OR(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(23, interpreter, scope);
if err != nil {
return nil, err }
res, err = opOr(pc, interpreter, scope);
*pc ++
return res, err }
func SI_SWAP7(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(150, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(8)
*pc ++
return res, err }
func SI_MSTORE8(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(83, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore8(pc, interpreter, scope);
*pc ++
return res, err }
func SI_XOR(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(24, interpreter, scope);
if err != nil {
return nil, err }
res, err = opXor(pc, interpreter, scope);
*pc ++
return res, err }
func SI_SWAP8(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(151, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(9)
*pc ++
return res, err }
func SI_SLOAD(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(84, interpreter, scope);
if err != nil {
return nil, err }
res, err = opSload(pc, interpreter, scope);
*pc ++
return res, err }
func SI_NOT(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(25, interpreter, scope);
if err != nil {
return nil, err }
res, err = opNot(pc, interpreter, scope);
*pc ++
return res, err }
func SI_SWAP9(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(152, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(10)
*pc ++
return res, err }
func SI_SSTORE(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(85, interpreter, scope);
if err != nil {
return nil, err }
if interpreter.readOnly && interpreter.evm.chainRules.IsByzantium {
    return nil, ErrWriteProtection
}
res, err = opSstore(pc, interpreter, scope);
*pc ++
return res, err }
func SI_BYTE(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(26, interpreter, scope);
if err != nil {
return nil, err }
res, err = opByte(pc, interpreter, scope);
*pc ++
return res, err }
func SI_SWAP10(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(153, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(11)
*pc ++
return res, err }
func SI_JUMP(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(86, interpreter, scope);
if err != nil {
return nil, err }
res, err = opJump(pc, interpreter, scope);
if err != nil {
return nil, err }
return res, err }
func SI_SHL(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(27, interpreter, scope);
if err != nil {
return nil, err }
res, err = opSHL(pc, interpreter, scope);
*pc ++
return res, err }
func SI_SWAP11(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(154, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(12)
*pc ++
return res, err }
func SI_SHR(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(28, interpreter, scope);
if err != nil {
return nil, err }
res, err = opSHR(pc, interpreter, scope);
*pc ++
return res, err }
func SI_SWAP12(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(155, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(13)
*pc ++
return res, err }
func SI_JUMPI(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(87, interpreter, scope);
if err != nil {
return nil, err }
res, err = opJumpi(pc, interpreter, scope);
if err != nil {
return nil, err }
return res, err }
func SI_PC(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(88, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPc(pc, interpreter, scope);
*pc ++
return res, err }
func SI_MSIZE(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(89, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMsize(pc, interpreter, scope);
*pc ++
return res, err }
func SI_GAS(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(90, interpreter, scope);
if err != nil {
return nil, err }
res, err = opGas(pc, interpreter, scope);
*pc ++
return res, err }
func SI_JUMPDEST(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(91, interpreter, scope);
if err != nil {
return nil, err }
res, err = opJumpdest(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH1(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(96, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush1(pc,interpreter, scope);
*pc ++
return res, err }
func SI_PUSH2(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(97, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush2(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH3(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(98, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush3(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH4(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(99, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush4(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH5(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(100, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush5(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH6(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(101, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush6(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH7(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(102, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush7(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH8(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(103, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush8(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH9(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(104, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush9(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH10(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(105, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush10(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH11(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(106, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush11(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH12(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(107, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush12(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH13(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(108, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush13(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH14(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(109, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush14(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH15(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(110, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush15(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH16(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(111, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush16(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH17(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(112, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush17(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH18(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(113, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush18(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH19(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(114, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush19(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH20(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(115, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush20(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH21(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(116, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush21(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH22(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(117, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush22(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH23(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(118, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush23(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH24(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(119, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush24(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH25(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(120, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush25(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH26(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(121, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush26(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH27(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(122, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush27(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH28(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(123, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush28(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH29(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(124, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush29(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH30(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(125, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush30(pc, interpreter, scope);
*pc ++
return res, err }
func SI_PUSH31(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(126, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush31(pc, interpreter, scope);
*pc ++
return res, err }
func SI_DUP12(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(139, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(12)
*pc ++
return res, err }
func SI_DUP13(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(140, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(13)
*pc ++
return res, err }
func SI_DUP14(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(141, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(14)
*pc ++
return res, err }
func SI_DUP15(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(142, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(15)
*pc ++
return res, err }
func SI_SWAP14(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(157, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(15)
*pc ++
return res, err }
func SI_SWAP15(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

err = gas_check(158, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(16)
*pc ++
return res, err }
func SI_265(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 1 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 1 }
} else if sLen > 1023 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1023}
}
err = aggregate_const_gas_check([]OpCode{128, 99, 20, 97, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(1)
*pc ++
res, err = opPush4(pc, interpreter, scope);
*pc ++
res, err = opEq(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_264(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 2 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 2 }
} else if sLen > 1024 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1024}
}
err = aggregate_const_gas_check([]OpCode{129, 82, 96, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(2)
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
return res, err;
}
func SI_258(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 0 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 0 }
} else if sLen > 1024 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1024}
}
err = aggregate_const_gas_check([]OpCode{91, 96, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opJumpdest(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
return res, err;
}
func SI_259(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 1 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 1 }
} else if sLen > 1024 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1024}
}
err = aggregate_const_gas_check([]OpCode{21, 97, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opIszero(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_260(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 2 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 2 }
} else if sLen > 1025 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1025}
}
err = aggregate_const_gas_check([]OpCode{80, 80, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
return res, err;
}
func SI_1184(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 8 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 8 }
} else if sLen > 1018 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1018}
}
err = aggregate_const_gas_check([]OpCode{91, 96, 128, 81, 127, 96, 148, 133, 27, 129, 22, 96, 128, 132, 1, 145, 144, 145, 82, 147, 133, 27, 129, 22, 96, 131, 1, 82, 130, 81, 96, 129, 132, 3, 1, 129, 82, 96, 131, 1, 132, 82, 128, 81, 144, 133, 1, 32, 127, 96, 132, 1, 82, 154, 144, 148, 27, 144, 147, 22, 96, 132, 1, 82, 96, 131, 1, 152, 144, 152, 82, 127, 96, 128, 132, 1, 145, 144, 145, 82, 136, 81, 128, 132, 3, 144, 145, 1, 129, 82, 96, 144, 146, 1, 144, 151, 82, 128, 81, 150, 1, 149, 144, 149, 32, 149, 148, 80, 80, 80, 80, 80, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opJumpdest(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.swap(6)
*pc ++
scope.Stack.dup(6)
*pc ++
res, err = opSHL(pc, interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(5)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.swap(3)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(3)
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
scope.Stack.swap(5)
*pc ++
scope.Stack.dup(6)
*pc ++
res, err = opSHL(pc, interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
scope.Stack.dup(3)
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(5)
*pc ++
res, err = opSub(pc, interpreter, scope);
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.dup(5)
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(6)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(32, interpreter, scope);
if err != nil {
return nil, err }
res, err = opSha3(pc, interpreter, scope);
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(5)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
scope.Stack.swap(12)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(6)
*pc ++
res, err = opSHL(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(5)
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(5)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.swap(10)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(10)
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(5)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.swap(3)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(3)
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
scope.Stack.dup(9)
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(5)
*pc ++
res, err = opSub(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(4)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(9)
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
scope.Stack.swap(8)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.swap(7)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(7)
*pc ++
err = dynamic_gas_check(32, interpreter, scope);
if err != nil {
return nil, err }
res, err = opSha3(pc, interpreter, scope);
*pc ++
scope.Stack.swap(7)
*pc ++
scope.Stack.swap(6)
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
return res, err;
}
func SI_266(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 0 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 0 }
} else if sLen > 1023 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1023}
}
err = aggregate_const_gas_check([]OpCode{96, 96, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
return res, err;
}
func SI_267(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 1 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 1 }
} else if sLen > 1025 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1025}
}
err = aggregate_const_gas_check([]OpCode{144, 80, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(2)
*pc ++
scope.Stack.pop()
*pc ++
return res, err;
}
func SI_333(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 3 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 3 }
} else if sLen > 1024 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1024}
}
err = aggregate_const_gas_check([]OpCode{115, 22, 115, 22, 129, 82, 96, 1, 144, 129, 82, 96, 1, 96, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush20(pc, interpreter, scope);
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
res, err = opPush20(pc, interpreter, scope);
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
return res, err;
}
func SI_268(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 1 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 1 }
} else if sLen > 1024 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1024}
}
err = aggregate_const_gas_check([]OpCode{96, 1, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_271(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 0 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 0 }
} else if sLen > 1024 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1024}
}
err = aggregate_const_gas_check([]OpCode{91, 97, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opJumpdest(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_272(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 2 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 2 }
} else if sLen > 1024 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1024}
}
err = aggregate_const_gas_check([]OpCode{129, 16, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(2)
*pc ++
res, err = opLt(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_275(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 2 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 2 }
} else if sLen > 1023 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1023}
}
err = aggregate_const_gas_check([]OpCode{128, 130, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
return res, err;
}
func SI_325(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 1 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 1 }
} else if sLen > 1023 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1023}
}
err = aggregate_const_gas_check([]OpCode{128, 99, 17, 97, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(1)
*pc ++
res, err = opPush4(pc, interpreter, scope);
*pc ++
res, err = opGt(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_276(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 1 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 1 }
} else if sLen > 1025 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1025}
}
err = aggregate_const_gas_check([]OpCode{91, 80, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opJumpdest(pc, interpreter, scope);
*pc ++
scope.Stack.pop()
*pc ++
return res, err;
}
func SI_496(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 3 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 3 }
} else if sLen > 1022 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1022}
}
err = aggregate_const_gas_check([]OpCode{129, 129, 1, 81, 131, 130, 1, 82, 96, 1, 97, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(2)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_411(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 2 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 2 }
} else if sLen > 1024 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1024}
}
err = aggregate_const_gas_check([]OpCode{144, 84, 144, 97, 10, 144, 4, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(2)
*pc ++
err = dynamic_gas_check(84, interpreter, scope);
if err != nil {
return nil, err }
res, err = opSload(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(10, interpreter, scope);
if err != nil {
return nil, err }
res, err = opExp(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
res, err = opDiv(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_274(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 2 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 2 }
} else if sLen > 1025 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1025}
}
err = aggregate_const_gas_check([]OpCode{144, 145, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(3)
*pc ++
return res, err;
}
func SI_303(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 0 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 0 }
} else if sLen > 1022 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1022}
}
err = aggregate_const_gas_check([]OpCode{96, 96, 96, 27, 3, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opSHL(pc, interpreter, scope);
*pc ++
res, err = opSub(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_399(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 0 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 0 }
} else if sLen > 1023 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1023}
}
err = aggregate_const_gas_check([]OpCode{96, 81, 128, 145, 3, 144, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush1(pc,interpreter, scope);
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opSub(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
return res, err;
}
func SI_306(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 3 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 3 }
} else if sLen > 1025 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1025}
}
err = aggregate_const_gas_check([]OpCode{91, 146, 145, 80, 80, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opJumpdest(pc, interpreter, scope);
*pc ++
scope.Stack.swap(4)
*pc ++
scope.Stack.swap(3)
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
return res, err;
}
func SI_17800(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 0 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 0 }
} else if sLen > 1015 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1015}
}
err = aggregate_const_gas_check([]OpCode{91, 127, 96, 81, 129, 96, 81, 129, 131, 129, 128, 130, 128, 9, 128, 9, 9, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 127, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 144, 130, 130, 96, 8, 131, 144, 129, 128, 130, 128, 9, 128, 9, 9, 131, 145, 8, 96, 82, 96, 82, 96, 96, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opJumpdest(pc, interpreter, scope);
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
res, err = opMulmod(pc, interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAddmod(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
return res, err;
}
func SI_383(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 0 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 0 }
} else if sLen > 1023 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1023}
}
err = aggregate_const_gas_check([]OpCode{96, 96, 82, 96, 54, 16, 97, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opCallDataSize(pc, interpreter, scope);
*pc ++
res, err = opLt(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_322(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 0 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 0 }
} else if sLen > 1023 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1023}
}
err = aggregate_const_gas_check([]OpCode{99, 97, 22, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush4(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_589(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 3 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 3 }
} else if sLen > 1024 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1024}
}
err = aggregate_const_gas_check([]OpCode{144, 146, 1, 145, 96, 145, 130, 1, 145, 1, 97, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(4)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.swap(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_337(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 1 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 1 }
} else if sLen > 1024 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1024}
}
err = aggregate_const_gas_check([]OpCode{96, 82, 96, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush1(pc,interpreter, scope);
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
return res, err;
}
func SI_286(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 1 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 1 }
} else if sLen > 1024 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1024}
}
err = aggregate_const_gas_check([]OpCode{128, 81, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(1)
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_710(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 1 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 1 }
} else if sLen > 1024 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1024}
}
err = aggregate_const_gas_check([]OpCode{91, 97, 81, 82, 96, 97, 81, 3, 97, 82, 97, 97, 81, 16, 21, 21, 97, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opJumpdest(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
res, err = opSub(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
res, err = opLt(pc, interpreter, scope);
*pc ++
res, err = opIszero(pc, interpreter, scope);
*pc ++
res, err = opIszero(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_345(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 2 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 2 }
} else if sLen > 1023 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1023}
}
err = aggregate_const_gas_check([]OpCode{129, 81, 129, 16, 97, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(2)
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
res, err = opLt(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_1454(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 9 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 9 }
} else if sLen > 1020 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1020}
}
err = aggregate_const_gas_check([]OpCode{91, 96, 131, 96, 3, 97, 10, 3, 128, 25, 130, 81, 22, 129, 132, 81, 22, 128, 130, 23, 133, 82, 80, 80, 80, 80, 80, 80, 144, 80, 1, 145, 80, 80, 96, 96, 81, 128, 131, 3, 129, 96, 134, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opJumpdest(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opSub(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(10, interpreter, scope);
if err != nil {
return nil, err }
res, err = opExp(pc, interpreter, scope);
*pc ++
res, err = opSub(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opNot(pc, interpreter, scope);
*pc ++
scope.Stack.dup(3)
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(5)
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opOr(pc, interpreter, scope);
*pc ++
scope.Stack.dup(6)
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.pop()
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.swap(3)
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(4)
*pc ++
res, err = opSub(pc, interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(7)
*pc ++
if !scope.Contract.UseGas(interpreter.cfg.JumpTable[90].constantGas){
		return nil, ErrOutOfGas
	}
res, err = opGas(pc, interpreter, scope);
*pc ++
if !scope.Contract.UseGas(interpreter.cfg.JumpTable[241].constantGas){
		return nil, ErrOutOfGas
	}
err = dynamic_gas_check(241, interpreter, scope);
if err != nil {
return nil, err }
if interpreter.readOnly && interpreter.evm.chainRules.IsByzantium && scope.Stack.Back(2).Sign() != 0 {
    return nil, ErrWriteProtection
}
res, err = opCall(pc, interpreter, scope);
interpreter.returnData = res 
*pc ++
err = aggregate_const_gas_check([]OpCode{145, 80, 80, 61, 128, 96, 129, 20, 97, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(3)
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
res, err = opReturnDataSize(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
res, err = opEq(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_282(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 2 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 2 }
} else if sLen > 1024 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1024}
}
err = aggregate_const_gas_check([]OpCode{129, 1, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(2)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_554(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 3 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 3 }
} else if sLen > 1024 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1024}
}
err = aggregate_const_gas_check([]OpCode{130, 82, 81, 144, 129, 144, 3, 96, 1, 144, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(3)
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.swap(2)
*pc ++
res, err = opSub(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
return res, err;
}
func SI_350(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 0 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 0 }
} else if sLen > 1022 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1022}
}
err = aggregate_const_gas_check([]OpCode{96, 96, 96, 10, 3, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
err = dynamic_gas_check(10, interpreter, scope);
if err != nil {
return nil, err }
res, err = opExp(pc, interpreter, scope);
*pc ++
res, err = opSub(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_287(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 2 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 2 }
} else if sLen > 1025 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1025}
}
err = aggregate_const_gas_check([]OpCode{22, 96, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opAnd(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
return res, err;
}
func SI_387(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 4 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 4 }
} else if sLen > 1025 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1025}
}
err = aggregate_const_gas_check([]OpCode{91, 147, 146, 80, 80, 80, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opJumpdest(pc, interpreter, scope);
*pc ++
scope.Stack.swap(5)
*pc ++
scope.Stack.swap(4)
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
return res, err;
}
func SI_291(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 2 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 2 }
} else if sLen > 1023 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1023}
}
err = aggregate_const_gas_check([]OpCode{129, 97, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(2)
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_705(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 0 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 0 }
} else if sLen > 1022 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1022}
}
err = aggregate_const_gas_check([]OpCode{91, 97, 81, 81, 96, 97, 81, 1, 97, 82, 97, 97, 81, 16, 21, 97, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opJumpdest(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
res, err = opLt(pc, interpreter, scope);
*pc ++
res, err = opIszero(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_292(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 2 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 2 }
} else if sLen > 1025 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1025}
}
err = aggregate_const_gas_check([]OpCode{91, 4, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opJumpdest(pc, interpreter, scope);
*pc ++
res, err = opDiv(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_290(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 3 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 3 }
} else if sLen > 1023 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1023}
}
err = aggregate_const_gas_check([]OpCode{128, 131, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(4)
*pc ++
return res, err;
}
func SI_293(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 2 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 2 }
} else if sLen > 1025 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1025}
}
err = aggregate_const_gas_check([]OpCode{145, 80, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.swap(3)
*pc ++
scope.Stack.pop()
*pc ++
return res, err;
}
func SI_277(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 3 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 3 }
} else if sLen > 1024 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1024}
}
err = aggregate_const_gas_check([]OpCode{130, 1, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(3)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_551(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 0 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 0 }
} else if sLen > 1023 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1023}
}
err = aggregate_const_gas_check([]OpCode{96, 53, 124, 144, 4, 99, 22, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opCallDataLoad(pc, interpreter, scope);
*pc ++
res, err = opPush29(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
res, err = opDiv(pc, interpreter, scope);
*pc ++
res, err = opPush4(pc, interpreter, scope);
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_2147(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 3 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 3 }
} else if sLen > 1014 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1014}
}
err = aggregate_const_gas_check([]OpCode{91, 96, 128, 81, 128, 130, 1, 130, 82, 96, 129, 82, 127, 96, 145, 130, 1, 82, 129, 81, 115, 133, 129, 22, 96, 131, 1, 82, 96, 128, 131, 1, 134, 144, 82, 132, 81, 128, 132, 3, 144, 145, 1, 129, 82, 96, 144, 146, 1, 132, 82, 145, 129, 1, 128, 81, 123, 22, 127, 23, 129, 82, 146, 81, 129, 81, 96, 148, 96, 148, 137, 22, 147, 146, 145, 130, 145, 144, 128, 131, 131, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opJumpdest(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.dup(3)
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.swap(3)
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
res, err = opPush20(pc, interpreter, scope);
*pc ++
scope.Stack.dup(6)
*pc ++
scope.Stack.dup(2)
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(4)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(4)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.dup(7)
*pc ++
scope.Stack.swap(2)
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
scope.Stack.dup(5)
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(5)
*pc ++
res, err = opSub(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(4)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.dup(5)
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
scope.Stack.swap(3)
*pc ++
scope.Stack.dup(2)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
res, err = opPush28(pc, interpreter, scope);
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opOr(pc, interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
scope.Stack.swap(4)
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.swap(6)
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.swap(6)
*pc ++
scope.Stack.dup(10)
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
scope.Stack.swap(5)
*pc ++
scope.Stack.swap(4)
*pc ++
scope.Stack.swap(3)
*pc ++
scope.Stack.dup(3)
*pc ++
scope.Stack.swap(3)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.dup(4)
*pc ++
return res, err;
}
func SI_523(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 6 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 6 }
} else if sLen > 1020 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1020}
}
err = aggregate_const_gas_check([]OpCode{129, 134, 128, 59, 21, 128, 21, 97, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.dup(2)
*pc ++
scope.Stack.dup(7)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opExtCodeSize(pc, interpreter, scope);
*pc ++
res, err = opIszero(pc, interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opIszero(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_2118(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if interpreter.readOnly && interpreter.evm.chainRules.IsByzantium {
    return nil, ErrWriteProtection
}
if sLen := scope.Stack.len(); sLen < 6 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 6 }
} else if sLen > 1018 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1018}
}
err = aggregate_const_gas_check([]OpCode{91, 96, 128, 84, 127, 22, 109, 136, 129, 22, 145, 144, 145, 23, 127, 22, 110, 136, 131, 22, 129, 2, 145, 144, 145, 23, 123, 22, 124, 99, 135, 22, 2, 23, 146, 131, 144, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opJumpdest(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
err = dynamic_gas_check(84, interpreter, scope);
if err != nil {
return nil, err }
res, err = opSload(pc, interpreter, scope);
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
res, err = opPush14(pc, interpreter, scope);
*pc ++
scope.Stack.dup(9)
*pc ++
scope.Stack.dup(2)
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
scope.Stack.swap(3)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opOr(pc, interpreter, scope);
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
res, err = opPush15(pc, interpreter, scope);
*pc ++
scope.Stack.dup(9)
*pc ++
scope.Stack.dup(4)
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
res, err = opMul(pc, interpreter, scope);
*pc ++
scope.Stack.swap(3)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opOr(pc, interpreter, scope);
*pc ++
res, err = opPush28(pc, interpreter, scope);
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
res, err = opPush29(pc, interpreter, scope);
*pc ++
res, err = opPush4(pc, interpreter, scope);
*pc ++
scope.Stack.dup(8)
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
res, err = opMul(pc, interpreter, scope);
*pc ++
res, err = opOr(pc, interpreter, scope);
*pc ++
scope.Stack.swap(4)
*pc ++
scope.Stack.dup(4)
*pc ++
scope.Stack.swap(2)
*pc ++
if !scope.Contract.UseGas(interpreter.cfg.JumpTable[85].constantGas){
		return nil, ErrOutOfGas
	}
err = dynamic_gas_check(85, interpreter, scope);
if err != nil {
return nil, err }
res, err = opSstore(pc, interpreter, scope);
*pc ++
err = aggregate_const_gas_check([]OpCode{96, 128, 81, 132, 132, 22, 129, 82, 145, 144, 147, 4, 144, 145, 22, 96, 130, 1, 82, 129, 81, 127, 146, 145, 129, 144, 3, 144, 145, 1, 144, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
scope.Stack.dup(5)
*pc ++
scope.Stack.dup(5)
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
scope.Stack.swap(3)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(5)
*pc ++
res, err = opDiv(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(3)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(82, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMstore(pc, interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
res, err = opPush32(pc, interpreter, scope);
*pc ++
scope.Stack.swap(4)
*pc ++
scope.Stack.swap(3)
*pc ++
scope.Stack.dup(2)
*pc ++
scope.Stack.swap(2)
*pc ++
res, err = opSub(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(3)
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
if !scope.Contract.UseGas(interpreter.cfg.JumpTable[161].constantGas){
		return nil, ErrOutOfGas
	}
err = dynamic_gas_check(161, interpreter, scope);
if err != nil {
return nil, err }
res, err = opLog1(pc, interpreter, scope);
*pc ++
err = aggregate_const_gas_check([]OpCode{80, 80, 80, 80, 80, 80, }, interpreter, scope);
if err != nil {
return nil, err }
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
return res, err;
}
func SI_421(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 0 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 0 }
} else if sLen > 1023 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1023}
}
err = aggregate_const_gas_check([]OpCode{96, 53, 96, 28, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opCallDataLoad(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opSHR(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_279(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 0 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 0 }
} else if sLen > 1024 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1024}
}
err = aggregate_const_gas_check([]OpCode{96, 81, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush1(pc,interpreter, scope);
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_305(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 2 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 2 }
} else if sLen > 1025 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1025}
}
err = aggregate_const_gas_check([]OpCode{1, 81, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opAdd(pc, interpreter, scope);
*pc ++
err = dynamic_gas_check(81, interpreter, scope);
if err != nil {
return nil, err }
res, err = opMload(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_476(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 0 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 0 }
} else if sLen > 1021 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1021}
}
err = aggregate_const_gas_check([]OpCode{96, 128, 54, 3, 96, 129, 16, 21, 97, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opCallDataSize(pc, interpreter, scope);
*pc ++
res, err = opSub(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(2)
*pc ++
res, err = opLt(pc, interpreter, scope);
*pc ++
res, err = opIszero(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
return res, err;
}
func SI_877(pc *uint64, interpreter *GethEVMInterpreter, scope *ScopeContext) ([]byte, error) {
var (
err error;
res []byte;
)

if sLen := scope.Stack.len(); sLen < 0 {
	return nil, &ErrStackUnderflow{stackLen: sLen, required: 0 }
} else if sLen > 1019 {
	return nil, &ErrStackOverflow{stackLen: sLen, limit: 1019}
}
err = aggregate_const_gas_check([]OpCode{91, 97, 96, 128, 128, 53, 115, 22, 144, 96, 1, 144, 145, 144, 128, 53, 144, 96, 1, 144, 145, 144, 80, 80, 97, }, interpreter, scope);
if err != nil {
return nil, err }
res, err = opJumpdest(pc, interpreter, scope);
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
scope.Stack.dup(1)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opCallDataLoad(pc, interpreter, scope);
*pc ++
res, err = opPush20(pc, interpreter, scope);
*pc ++
res, err = opAnd(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(3)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.dup(1)
*pc ++
res, err = opCallDataLoad(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
res, err = opPush1(pc,interpreter, scope);
*pc ++
res, err = opAdd(pc, interpreter, scope);
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.swap(3)
*pc ++
scope.Stack.swap(2)
*pc ++
scope.Stack.pop()
*pc ++
scope.Stack.pop()
*pc ++
res, err = opPush2(pc, interpreter, scope);
*pc ++
return res, err;
}
const NUM_OF_SI = 50
var sivm_jump_table [307]executionFunc
var si_db [307][]byte
func init() {
init_jump_table() 
init_si_db() 
}
func init_jump_table() {
for i := 0; i < 256; i++ {
sivm_jump_table[i] = opInvalid
}
sivm_jump_table[SIVM_NOP] = opNop
sivm_jump_table[SELFDESTRUCT] = SI_SELFDESTRUCT;
sivm_jump_table[REVERT] = SI_REVERT;
sivm_jump_table[STATICCALL] = SI_STATICCALL;
sivm_jump_table[CREATE2] = SI_CREATE2;
sivm_jump_table[DELEGATECALL] = SI_DELEGATECALL;
sivm_jump_table[RETURN] = SI_RETURN;
sivm_jump_table[CALLCODE] = SI_CALLCODE;
sivm_jump_table[CALL] = SI_CALL;
sivm_jump_table[CREATE] = SI_CREATE;
sivm_jump_table[LOG4] = SI_LOG4;
sivm_jump_table[LOG3] = SI_LOG3;
sivm_jump_table[LOG2] = SI_LOG2;
sivm_jump_table[LOG1] = SI_LOG1;
sivm_jump_table[LOG0] = SI_LOG0;
sivm_jump_table[SWAP16] = SI_SWAP16;
sivm_jump_table[BASEFEE] = SI_BASEFEE;
sivm_jump_table[SELFBALANCE] = SI_SELFBALANCE;
sivm_jump_table[GASPRICE] = SI_GASPRICE;
sivm_jump_table[CODECOPY] = SI_CODECOPY;
sivm_jump_table[CODESIZE] = SI_CODESIZE;
sivm_jump_table[CALLDATACOPY] = SI_CALLDATACOPY;
sivm_jump_table[CALLDATASIZE] = SI_CALLDATASIZE;
sivm_jump_table[CALLDATALOAD] = SI_CALLDATALOAD;
sivm_jump_table[CALLVALUE] = SI_CALLVALUE;
sivm_jump_table[CALLER] = SI_CALLER;
sivm_jump_table[ORIGIN] = SI_ORIGIN;
sivm_jump_table[CHAINID] = SI_CHAINID;
sivm_jump_table[SIGNEXTEND] = SI_SIGNEXTEND;
sivm_jump_table[DUP11] = SI_DUP11;
sivm_jump_table[GASLIMIT] = SI_GASLIMIT;
sivm_jump_table[EXP] = SI_EXP;
sivm_jump_table[DUP10] = SI_DUP10;
sivm_jump_table[DIFFICULTY] = SI_DIFFICULTY;
sivm_jump_table[MULMOD] = SI_MULMOD;
sivm_jump_table[DUP9] = SI_DUP9;
sivm_jump_table[NUMBER] = SI_NUMBER;
sivm_jump_table[ADDMOD] = SI_ADDMOD;
sivm_jump_table[DUP8] = SI_DUP8;
sivm_jump_table[TIMESTAMP] = SI_TIMESTAMP;
sivm_jump_table[SMOD] = SI_SMOD;
sivm_jump_table[DUP7] = SI_DUP7;
sivm_jump_table[COINBASE] = SI_COINBASE;
sivm_jump_table[MOD] = SI_MOD;
sivm_jump_table[DUP6] = SI_DUP6;
sivm_jump_table[BLOCKHASH] = SI_BLOCKHASH;
sivm_jump_table[SDIV] = SI_SDIV;
sivm_jump_table[DUP5] = SI_DUP5;
sivm_jump_table[EXTCODEHASH] = SI_EXTCODEHASH;
sivm_jump_table[DIV] = SI_DIV;
sivm_jump_table[DUP4] = SI_DUP4;
sivm_jump_table[LT] = SI_LT;
sivm_jump_table[DUP16] = SI_DUP16;
sivm_jump_table[RETURNDATACOPY] = SI_RETURNDATACOPY;
sivm_jump_table[SUB] = SI_SUB;
sivm_jump_table[DUP3] = SI_DUP3;
sivm_jump_table[SHA3] = SI_SHA3;
sivm_jump_table[RETURNDATASIZE] = SI_RETURNDATASIZE;
sivm_jump_table[MUL] = SI_MUL;
sivm_jump_table[DUP2] = SI_DUP2;
sivm_jump_table[EXTCODECOPY] = SI_EXTCODECOPY;
sivm_jump_table[ADD] = SI_ADD;
sivm_jump_table[DUP1] = SI_DUP1;
sivm_jump_table[EXTCODESIZE] = SI_EXTCODESIZE;
sivm_jump_table[STOP] = SI_STOP;
sivm_jump_table[PUSH32] = SI_PUSH32;
sivm_jump_table[SAR] = SI_SAR;
sivm_jump_table[SWAP13] = SI_SWAP13;
sivm_jump_table[GT] = SI_GT;
sivm_jump_table[SWAP1] = SI_SWAP1;
sivm_jump_table[SLT] = SI_SLT;
sivm_jump_table[SWAP2] = SI_SWAP2;
sivm_jump_table[SGT] = SI_SGT;
sivm_jump_table[SWAP3] = SI_SWAP3;
sivm_jump_table[ADDRESS] = SI_ADDRESS;
sivm_jump_table[EQ] = SI_EQ;
sivm_jump_table[SWAP4] = SI_SWAP4;
sivm_jump_table[BALANCE] = SI_BALANCE;
sivm_jump_table[POP] = SI_POP;
sivm_jump_table[ISZERO] = SI_ISZERO;
sivm_jump_table[SWAP5] = SI_SWAP5;
sivm_jump_table[MLOAD] = SI_MLOAD;
sivm_jump_table[AND] = SI_AND;
sivm_jump_table[SWAP6] = SI_SWAP6;
sivm_jump_table[MSTORE] = SI_MSTORE;
sivm_jump_table[OR] = SI_OR;
sivm_jump_table[SWAP7] = SI_SWAP7;
sivm_jump_table[MSTORE8] = SI_MSTORE8;
sivm_jump_table[XOR] = SI_XOR;
sivm_jump_table[SWAP8] = SI_SWAP8;
sivm_jump_table[SLOAD] = SI_SLOAD;
sivm_jump_table[NOT] = SI_NOT;
sivm_jump_table[SWAP9] = SI_SWAP9;
sivm_jump_table[SSTORE] = SI_SSTORE;
sivm_jump_table[BYTE] = SI_BYTE;
sivm_jump_table[SWAP10] = SI_SWAP10;
sivm_jump_table[JUMP] = SI_JUMP;
sivm_jump_table[SHL] = SI_SHL;
sivm_jump_table[SWAP11] = SI_SWAP11;
sivm_jump_table[SHR] = SI_SHR;
sivm_jump_table[SWAP12] = SI_SWAP12;
sivm_jump_table[JUMPI] = SI_JUMPI;
sivm_jump_table[PC] = SI_PC;
sivm_jump_table[MSIZE] = SI_MSIZE;
sivm_jump_table[GAS] = SI_GAS;
sivm_jump_table[JUMPDEST] = SI_JUMPDEST;
sivm_jump_table[PUSH1] = SI_PUSH1;
sivm_jump_table[PUSH2] = SI_PUSH2;
sivm_jump_table[PUSH3] = SI_PUSH3;
sivm_jump_table[PUSH4] = SI_PUSH4;
sivm_jump_table[PUSH5] = SI_PUSH5;
sivm_jump_table[PUSH6] = SI_PUSH6;
sivm_jump_table[PUSH7] = SI_PUSH7;
sivm_jump_table[PUSH8] = SI_PUSH8;
sivm_jump_table[PUSH9] = SI_PUSH9;
sivm_jump_table[PUSH10] = SI_PUSH10;
sivm_jump_table[PUSH11] = SI_PUSH11;
sivm_jump_table[PUSH12] = SI_PUSH12;
sivm_jump_table[PUSH13] = SI_PUSH13;
sivm_jump_table[PUSH14] = SI_PUSH14;
sivm_jump_table[PUSH15] = SI_PUSH15;
sivm_jump_table[PUSH16] = SI_PUSH16;
sivm_jump_table[PUSH17] = SI_PUSH17;
sivm_jump_table[PUSH18] = SI_PUSH18;
sivm_jump_table[PUSH19] = SI_PUSH19;
sivm_jump_table[PUSH20] = SI_PUSH20;
sivm_jump_table[PUSH21] = SI_PUSH21;
sivm_jump_table[PUSH22] = SI_PUSH22;
sivm_jump_table[PUSH23] = SI_PUSH23;
sivm_jump_table[PUSH24] = SI_PUSH24;
sivm_jump_table[PUSH25] = SI_PUSH25;
sivm_jump_table[PUSH26] = SI_PUSH26;
sivm_jump_table[PUSH27] = SI_PUSH27;
sivm_jump_table[PUSH28] = SI_PUSH28;
sivm_jump_table[PUSH29] = SI_PUSH29;
sivm_jump_table[PUSH30] = SI_PUSH30;
sivm_jump_table[PUSH31] = SI_PUSH31;
sivm_jump_table[DUP12] = SI_DUP12;
sivm_jump_table[DUP13] = SI_DUP13;
sivm_jump_table[DUP14] = SI_DUP14;
sivm_jump_table[DUP15] = SI_DUP15;
sivm_jump_table[SWAP14] = SI_SWAP14;
sivm_jump_table[SWAP15] = SI_SWAP15;
sivm_jump_table[257] = SI_265;
sivm_jump_table[258] = SI_264;
sivm_jump_table[259] = SI_258;
sivm_jump_table[260] = SI_259;
sivm_jump_table[261] = SI_260;
sivm_jump_table[262] = SI_1184;
sivm_jump_table[263] = SI_266;
sivm_jump_table[264] = SI_267;
sivm_jump_table[265] = SI_333;
sivm_jump_table[266] = SI_268;
sivm_jump_table[267] = SI_271;
sivm_jump_table[268] = SI_272;
sivm_jump_table[269] = SI_275;
sivm_jump_table[270] = SI_325;
sivm_jump_table[271] = SI_276;
sivm_jump_table[272] = SI_496;
sivm_jump_table[273] = SI_411;
sivm_jump_table[274] = SI_274;
sivm_jump_table[275] = SI_303;
sivm_jump_table[276] = SI_399;
sivm_jump_table[277] = SI_306;
sivm_jump_table[278] = SI_17800;
sivm_jump_table[279] = SI_383;
sivm_jump_table[280] = SI_322;
sivm_jump_table[281] = SI_589;
sivm_jump_table[282] = SI_337;
sivm_jump_table[283] = SI_286;
sivm_jump_table[284] = SI_710;
sivm_jump_table[285] = SI_345;
sivm_jump_table[286] = SI_1454;
sivm_jump_table[287] = SI_282;
sivm_jump_table[288] = SI_554;
sivm_jump_table[289] = SI_350;
sivm_jump_table[290] = SI_287;
sivm_jump_table[291] = SI_387;
sivm_jump_table[292] = SI_291;
sivm_jump_table[293] = SI_705;
sivm_jump_table[294] = SI_292;
sivm_jump_table[295] = SI_290;
sivm_jump_table[296] = SI_293;
sivm_jump_table[297] = SI_277;
sivm_jump_table[298] = SI_551;
sivm_jump_table[299] = SI_2147;
sivm_jump_table[300] = SI_523;
sivm_jump_table[301] = SI_2118;
sivm_jump_table[302] = SI_421;
sivm_jump_table[303] = SI_279;
sivm_jump_table[304] = SI_305;
sivm_jump_table[305] = SI_476;
sivm_jump_table[306] = SI_877;
}

func init_si_db() {
si_db[257] = []byte{128,99,20,97,}
si_db[258] = []byte{129,82,96,}
si_db[259] = []byte{91,96,}
si_db[260] = []byte{21,97,}
si_db[261] = []byte{80,80,}
si_db[262] = []byte{91,96,128,81,127,96,148,133,27,129,22,96,128,132,1,145,144,145,82,147,133,27,129,22,96,131,1,82,130,81,96,129,132,3,1,129,82,96,131,1,132,82,128,81,144,133,1,32,127,96,132,1,82,154,144,148,27,144,147,22,96,132,1,82,96,131,1,152,144,152,82,127,96,128,132,1,145,144,145,82,136,81,128,132,3,144,145,1,129,82,96,144,146,1,144,151,82,128,81,150,1,149,144,149,32,149,148,80,80,80,80,80,}
si_db[263] = []byte{96,96,}
si_db[264] = []byte{144,80,}
si_db[265] = []byte{115,22,115,22,129,82,96,1,144,129,82,96,1,96,}
si_db[266] = []byte{96,1,}
si_db[267] = []byte{91,97,}
si_db[268] = []byte{129,16,}
si_db[269] = []byte{128,130,}
si_db[270] = []byte{128,99,17,97,}
si_db[271] = []byte{91,80,}
si_db[272] = []byte{129,129,1,81,131,130,1,82,96,1,97,}
si_db[273] = []byte{144,84,144,97,10,144,4,}
si_db[274] = []byte{144,145,}
si_db[275] = []byte{96,96,96,27,3,}
si_db[276] = []byte{96,81,128,145,3,144,}
si_db[277] = []byte{91,146,145,80,80,}
si_db[278] = []byte{91,127,96,81,129,96,81,129,131,129,128,130,128,9,128,9,9,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,127,8,131,144,129,128,130,128,9,128,9,9,131,145,8,144,130,130,96,8,131,144,129,128,130,128,9,128,9,9,131,145,8,96,82,96,82,96,96,}
si_db[279] = []byte{96,96,82,96,54,16,97,}
si_db[280] = []byte{99,97,22,}
si_db[281] = []byte{144,146,1,145,96,145,130,1,145,1,97,}
si_db[282] = []byte{96,82,96,}
si_db[283] = []byte{128,81,}
si_db[284] = []byte{91,97,81,82,96,97,81,3,97,82,97,97,81,16,21,21,97,}
si_db[285] = []byte{129,81,129,16,97,}
si_db[286] = []byte{91,96,131,96,3,97,10,3,128,25,130,81,22,129,132,81,22,128,130,23,133,82,80,80,80,80,80,80,144,80,1,145,80,80,96,96,81,128,131,3,129,96,134,90,241,145,80,80,61,128,96,129,20,97,}
si_db[287] = []byte{129,1,}
si_db[288] = []byte{130,82,81,144,129,144,3,96,1,144,}
si_db[289] = []byte{96,96,96,10,3,}
si_db[290] = []byte{22,96,}
si_db[291] = []byte{91,147,146,80,80,80,}
si_db[292] = []byte{129,97,}
si_db[293] = []byte{91,97,81,81,96,97,81,1,97,82,97,97,81,16,21,97,}
si_db[294] = []byte{91,4,}
si_db[295] = []byte{128,131,}
si_db[296] = []byte{145,80,}
si_db[297] = []byte{130,1,}
si_db[298] = []byte{96,53,124,144,4,99,22,}
si_db[299] = []byte{91,96,128,81,128,130,1,130,82,96,129,82,127,96,145,130,1,82,129,81,115,133,129,22,96,131,1,82,96,128,131,1,134,144,82,132,81,128,132,3,144,145,1,129,82,96,144,146,1,132,82,145,129,1,128,81,123,22,127,23,129,82,146,81,129,81,96,148,96,148,137,22,147,146,145,130,145,144,128,131,131,}
si_db[300] = []byte{129,134,128,59,21,128,21,97,}
si_db[301] = []byte{91,96,128,84,127,22,109,136,129,22,145,144,145,23,127,22,110,136,131,22,129,2,145,144,145,23,123,22,124,99,135,22,2,23,146,131,144,85,96,128,81,132,132,22,129,82,145,144,147,4,144,145,22,96,130,1,82,129,81,127,146,145,129,144,3,144,145,1,144,161,80,80,80,80,80,80,}
si_db[302] = []byte{96,53,96,28,}
si_db[303] = []byte{96,81,}
si_db[304] = []byte{1,81,}
si_db[305] = []byte{96,128,54,3,96,129,16,21,97,}
si_db[306] = []byte{91,97,96,128,128,53,115,22,144,96,1,144,145,144,128,53,144,96,1,144,145,144,80,80,97,}
}
